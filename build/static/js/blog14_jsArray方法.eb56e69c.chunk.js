(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{t91g:function(n,e,r){"use strict";r.r(e);var a=r("q1tI"),s=r.n(a),t=r("IujW"),i=r.n(t);e.default=function(){return s.a.createElement(i.a,{source:"首先来个介绍一个js[测试](https://github.com/rmurphey/js-assessment) 要求先安装nodejs\n\n里面有个array的test 要求写一个remove fn去重数组中指定元素 \n```\nvar a = [1, 2, 2, 3, 4, 5, 2]\nvar s = remove(a, 2); //[1, 3, 4, 5]\nconsole.log(a); // [1, 2, 2, 3, 4, 5, 2]\n```\n这个问题很好解决\n```\nfunction remove (arr, item) {\n  return arr.fliter(function (v, i) {\n    return v != item;\n  })\n}\n```\n不过里面还有一个要求 写一个removeWithoutCopy方法 要求原数组同样改变,即直接操作原数组\n```\nvar a = [1, 2, 2, 3, 4, 5, 2]\nvar s = removeWithoutCopy(a, 2);//[1, 3, 4, 5]\nconsole.log(a); //[1, 3, 4, 5]\n```\n解决方法\n```\nfunction removeWithoutCopy (arr, item) {\n  while(arr.indexOf(item) > -1) {\n    arr.splice(arr.indexOf(item), 1);\n  }\n  return arr;\n}\n```\n这2个测试用到了filter及splice方法，这2个方法区别就是是否改变原数组\n\n下面就列一下Array的各种方法,举例说明对原数组的操作以及返回值\n```\n//每次操作中a = [1,2,3,4]\n//栈、队列方法\ns = a.push(5, 6); // a: [1,2,3,4,5,6] s: 6 /== a.length\ns = a.pop(); // a: [1,2,3] s: 4 /==移出的项\ns = a.unshift(5, 6); // a: [5,6,1,2,3,4] s: 6 /==a.length\ns = a.shift(); //a: [2,3,4] s: 1\n\n//重排序方法\na = [4,3,2,1]\ns = a.reverse(); //a: [1,2,3,4] s: [1,2,3,4]\ns = a.sort(); //a: [1,2,3,4] s: [1,2,3,4]\n\n//操作方法\na=[4,3,2,1]\ns = a.concat([5]); //a: [4,3,2,1] s: [4,3,2,1,5]\ns = a.slice(1); //a: [4] s: [3,2,1]\ns = a.splice(0, 1); //a: [3,2,1] s: [4] 删除操作\ns = a.splice(1, 0, \"a\") //a: [4,'a',3,2,1] s:[] 插入操作\ns = a.splice(1, 1, \"a\", \"b\") //a: [4,'a','b',2,1] s:[3] 替换操作\n\n//位置方法 ie9+,ff,chrome...\na=[4,3,2,1,4]\ns = a.indexOf(4); //a: [4,3,2,1] s: 0\ns = a.lastIndexOf(4); //a: [4,3,2,1] s: 4\n\n//迭代方法 ie9+,ff,chrome...\nforEach: 对数组中每一项运行给定函数, 无返回值, 对原数组也不会产生影响 相当于for循环\ns = a.forEach(function (v, i) {\n  console.log(v)\n}) // a: [4,3,2,1] s: undifined\n\nevery: 对数组中每一项运行给定函数，如果该函数对每一项都返回true, 则返回true\nvar a = [4,3,2,1]\ns = a.every(function (v, i) {\n  return v > 0;\n}) // a: [4,3,2,1] s: true\n\nsome: 对数组中每一项运行给定函数，如果该函数对任一项返回true，则返回true\ns = a.some(function (v, i) {\n  return v > 3;\n}) // a: [4,3,2,1] s: true\n\nfilter: 对数组中每一项运行给定函数，返回该函数会返回true的项组成的数组\ns = a.filter(function (v, i) {\n  return v > 2;\n}) // a: [4,3,2,1] s: [4,3]\n\n\nmap: 对数组中每一项运行给定函数，返回每次函数调用返回值组成的数组\ns = a.map(function (v, i) {\n  return v * 2;\n}) // a: [4,3,2,1] s: [8,6,4,1]\n\n//归并方法 //ie9+,ff,chrome...\nreduce: 迭代数组所有想，返回构建一个最终返回值\na = [1,2,3,4]\ns = a.reduce(function(prev, cur, index, array) {\n  console.log(prev, cur)\n  return prev +　cur\n}, 5) \n// 5 1\n// 6 2\n// 8 3\n// 11 4\n// 15\n// a: [1,2,3,4] s:15 5为初始值 是第一次迭代时prev的值 prev为前一个值 cur为当前值\n\nreduceRight 为从最后一项往前开始迭代\n```\n\n总结 array的操作方法中 会改动原数组的方法有pop,push,shift,unshift,splice这几个方法",htmlMode:"raw"})}}}]);