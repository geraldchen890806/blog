(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{Xf0W:function(n,e){n.exports="  遍历器（Iterator）是一种接口，为各种不同的数据结构提供统一的访问机制。\n\n  对于可迭代的数据解构，ES6在内部部署了一个[Symbol.iterator]属性，它是一个函数，执行后会返回iterator对象（也叫迭代器对象，也叫iterator接口），拥有[Symbol.iterator]属性的对象即被视为可迭代的\n  \n  Iterator也是另外4个ES6常用特性的实现基础（解构赋值，剩余/扩展运算符，生成器，for of循环)\n### Iterator 的遍历过程\n  1. 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。\n\n  2. 第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。\n\n  3. 第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。\n\n  4. 不断调用指针对象的next方法，直到它指向数据结构的结束位置。\n\n```\nvar it = makeIterator(['a', 'b']);\n\nit.next() // { value: \"a\", done: false }\nit.next() // { value: \"b\", done: false }\nit.next() // { value: undefined, done: true }\n\nfunction makeIterator(array) {\n  var nextIndex = 0;\n  return {\n    next: function() {\n      return nextIndex < array.length ?\n        {value: array[nextIndex++], done: false} :\n        {value: undefined, done: true};\n    }\n  };\n}\n  \n```\n## for...of\n  Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即for...of循环。当使用for...of循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。  \n\n### 原生具备 Iterator 接口的数据结构如下。\n  - Array\n  - Map\n  - Set\n  - String\n  - TypedArray\n  - 函数的 arguments 对象\n  - NodeList 对象\n\n### object使用for...of\n1. 为object添加[Symbol.iterator]和next方法\n```\nclass RangeIterator {\n  constructor(start, stop) {\n    this.value = start;\n    this.stop = stop;\n  }\n\n  [Symbol.iterator]() { return this; }\n\n  next() {\n    var value = this.value;\n    if (value < this.stop) {\n      this.value++;\n      return {done: false, value: value};\n    }\n    return {done: true, value: undefined};\n  }\n}\n\nfunction range(start, stop) {\n  return new RangeIterator(start, stop);\n}\n\nfor (var value of range(0, 3)) {\n  console.log(value); // 0, 1, 2\n}\n```\n2. 借用Array的Symbol.iterator\n```\nlet iterable = {\n  0: 'a',\n  1: 'b',\n  2: 'c',\n  length: 3,\n  [Symbol.iterator]: Array.prototype[Symbol.iterator] // [][Symbol.iterator];\n};\nfor (let item of iterable) {\n  console.log(item); // 'a', 'b', 'c'\n}\n```\n3. 使用generator函数\n```\nlet obj = {\n  * [Symbol.iterator]() {\n    yield 'hello';\n    yield 'world';\n  }\n};\n\nfor (let x of obj) {\n  console.log(x);\n}\n// \"hello\"\n// \"world\"\n\n\nfunction* entries(obj) {\n  for (let key of Object.keys(obj)) {\n    yield [key, obj[key]];\n  }\n}\n\nfor (let [key, value] of entries(obj)) {\n  console.log(key, '->', value);\n}\n// a -> 1\n// b -> 2\n// c -> 3\n```\n4. 使用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组。\n```\nfor (var key of Object.keys(someObject)) {\n  console.log(key + ': ' + someObject[key]);\n}\n```\n## yield*\n  yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。\n```\n  let generator = function* () {\n    yield 1;\n    yield* [2,3,4];\n    yield 5;\n  };\n\n  var iterator = generator();\n\n  iterator.next() // { value: 1, done: false }\n  iterator.next() // { value: 2, done: false }\n  iterator.next() // { value: 3, done: false }\n  iterator.next() // { value: 4, done: false }\n  iterator.next() // { value: 5, done: false }\n  iterator.next() // { value: undefined, done: true }\n```\n\n参考： [阮一峰：ES6标准入门](http://es6.ruanyifeng.com/)"},xZB2:function(n,e,t){"use strict";t.r(e);var r=t("q1tI"),o=t.n(r),a=t("IujW"),l=t.n(a),i=t("Xf0W"),u=t.n(i);e.default=function(){return o.a.createElement(l.a,{source:u.a,htmlMode:"raw"})}}}]);