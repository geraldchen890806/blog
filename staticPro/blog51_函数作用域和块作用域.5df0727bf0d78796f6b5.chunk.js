(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{E1e0:function(n,o,e){"use strict";e.r(o);var a=e("q1tI"),i=e.n(a),c=e("IujW"),l=e.n(c),t=e("cKJV"),f=e.n(t);o.default=function(){return i.a.createElement(l.a,{source:f.a,htmlMode:"raw"})}},cKJV:function(n,o){n.exports="### 作用域：隐藏内部实现\n\n最小授权/最小暴露原则：指在软件设计中，应该最小限度地暴露必 要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计\n\n1. 防止某些内部函数被有意或无意地以非预期的方式使用\n\n```\nfunction doSomething(a) {\n  function doSomethingElse(a) {\n    return a - 1;\n  }\n  var b;\n  b = a + doSomethingElse( a * 2 ); // 放在被错误调用，比如传递无效参数，无法预期结果\n  console.log( b * 3 );\n}\ndoSomething( 2 ); // 15\n```\n\n2. 避免同名标识符之间的冲突\n\n```\nfunction foo() {\n  function bar(a) {\n    i = 3;\n    console.log( a + i );\n  }\n  for (var i=0; i<10; i++) {\n    bar( i * 2 );\n  }\n}\nfoo();\n```\n\n#### 比较2个代码\n```\nvar a = 2;\n\nfunction foo() {\n  var a = 3;\n  console.log( a ); // 3\n}\n\nfoo();\nconsole.log( a ); // 2\n\n```\n\n```\nvar a = 2;\n\n(function foo() {\n  var a = 3;\n  console.log( a ); // 3\n})();\n\nconsole.log( a ); // 2\n\n```\n\n第一个例子使用 foo 避免了变量名 a 的冲突，但是当前作用域多了个 foo 并且需要显示调用 foo\n\n第二个例子使用一种特殊的函数表达式： 立即执行函数表达式(IIFE)\n\n### 函数表达式\n\n区分函数声明和表达式最简单的方法是看 function 关键字出现在声明中的位 置(不仅仅是一行代码，而是整个声明中的位置)。如果 function 是声明中 的第一个词，那么就是一个函数声明，否则就是一个函数表达式。\n\nIIFE 的 2 种特殊应用场景：\n\n1.重置undefined\n  // es3中undefined可以赋值，es5才做了修正,变为只读\n\n```\nundefined = true; // 给其他代码挖了一个大坑!绝对不要这样做!\n(function IIFE( undefined ) {\n  var a;\n  if (a === undefined) {\n  console.log( \"Undefined is safe here!\" );\n  }\n})();\n\n```\n\n2.倒置代码的运行顺序，将需要运行的函数放在第二位\n\n```\nvar a = 2;\n(function IIFE( def ) {\n  def( window );\n})(function def( global ) {\n  var a = 3;\n  console.log( a ); // 3\n  console.log( global.a ); // 2\n});\n```\n\n### 另一种函数表达式：匿名函数表达式\n\n最常见的回调参数：\n\n```\nsetTimeout(function() {\n  console.log(\"I waited 1 second!\");\n}, 1000 );\n```\n\n缺点：\n\n1. 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难\n2. 函数需要引用自身时只能使用已经过期的 arguments.callee 引用\n3. 匿名函数省略了对于代码可读性/可理解性很重要的函数名\n\n\n\n\n下面介绍除了函数作用域（属于这个函数的全部变量都可以在整个函数的范围内使用及复用）外的另一个作用域单元\n\n## 块作用域\n1.with\n\n2.try/catch 的 catch 分句会创建一个块作用域\n\n3.let\n// let 关键字可以将变量绑定到所在的任意作用域中(通常是 { 为其声明的变量隐式地劫持了所在的块作用域。\n```\nif (true) {\n  {\n    let i = 11;\n    var s = 11;\n    console.log('i1', i);\n  }\n  console.log('i2', i);\n  console.log('s1', s);\n}\n\nconsole.log('s2', s);\nconsole.log('i3', i);\n```\n\n4.const\n\n// 块作用域非常有用的原因和闭包及回收内存垃圾的回收机制相关"}}]);