(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{rzIO:function(n,e,a){"use strict";a.r(e);var i=a("q1tI"),c=a.n(i),l=a("IujW"),r=a.n(l);e.default=function(){return c.a.createElement(r.a,{source:"## 环境配置\n\nexport GOPATH=$HOME/go\nexport GOBIN=$HOME/go/bin\nexport PATH=\"$GOPATH/bin:$PATH\"\n\n### (Go 命令)[https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/01.3.md]\n\n#### package main\n\ngo build(go/pkg)\ngo install(go/bin)\ngo get\n\n## Go 语言基础\n\n### 定义变量 (Boolean,数值类型,字符串,error, iota)\n\n```\n1. var vname1, vname2, vname3 type\n2. var vname1, vname2, vname3 type= v1, v2, v3\n3. vname1, vname2, vname3 := v1, v2, v3\n// Go里面有一个关键字iota，这个关键字用来声明enum的时候采用，它默认开始值是0，const中每增加一行加1：\n4.\n  const (\n    a       = iota //a=0\n    b       = \"B\"\n    c       = iota             //c=2\n    d, e, f = iota, iota, iota //d=3,e=3,f=3\n    g       = iota             //g = 4\n  )\n```\n\n#### array\n\n```\n1. var arr [10]int\n2. b := [10]int{1, 2, 3} // 声明了一个长度为10的int数组，其中前三个元素初始化为1、2、3，其它默认为0\n3. c := [...]int{4, 5, 6} // 可以省略长度而采用`...`的方式，Go会自动根据元素个数来计算长度\n4. // 声明了一个二维数组，该数组以两个数组作为元素，其中每个数组中又有4个int类型的元素\n  doubleArray := [2][4]int{[4]int{1, 2, 3, 4}, [4]int{5, 6, 7, 8}}\n```\n\n#### slice\n\nslice 是引用类型，所以当引用改变其中元素的值时，其它的所有引用都会改变该值，例如上面的 aSlice 和 bSlice，如果修改了 aSlice 中元素的值，那么 bSlice 相对应的值也会改变。\n\n```\n// 声明一个数组\nvar array = [10]byte{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}\n// 声明两个slice\nvar aSlice, bSlice []byte\n\n// 演示一些简便操作\naSlice = array[:3] // 等价于aSlice = array[0:3] aSlice包含元素: a,b,c\naSlice = array[5:] // 等价于aSlice = array[5:10] aSlice包含元素: f,g,h,i,j\naSlice = array[:]  // 等价于aSlice = array[0:10] 这样aSlice包含了全部的元素\n\n// 从slice中获取slice\naSlice = array[3:7]  // aSlice包含元素: d,e,f,g，len=4，cap=7\nbSlice = aSlice[1:3] // bSlice 包含aSlice[1], aSlice[2] 也就是含有: e,f\nbSlice = aSlice[:3]  // bSlice 包含 aSlice[0], aSlice[1], aSlice[2] 也就是含有: d,e,f\nbSlice = aSlice[0:5] // 对slice的slice可以在cap范围内扩展，此时bSlice包含：d,e,f,g,h\nbSlice = aSlice[:]   // bSlice包含所有aSlice的元素: d,e,f,g\n\n// 从Go1.2开始slice支持了三个参数的slice，之前我们一直采用这种方式在slice或者array基础上来获取一个slice\nvar array [10]int\nslice := array[2:4] slice的容量是8\nslice = array[2:4:7] 新版本里面可以指定这个容量, 容量就是7-2，即5。这样这个产生的新的slice就没办法访问最后的三个元素。\n```\n\n#### map\n\nmap 的读取和设置也类似 slice 一样，通过 key 来操作，只是 slice 的 index 只能是｀ int ｀类型，而 map 多了很多类型，可以是 int，可以是 string 及所有完全定义了==与!=操作的类型。\n\n1. map 是无序的，每次打印出来的 map 都会不一样，它不能通过 index 获取，而必须通过 key 获取\n2. map 的长度是不固定的，也就是和 slice 一样，也是一种引用类型\n3. 内置的 len 函数同样适用于 map，返回 map 拥有的 key 的数量\n4. map 的值可以很方便的修改，通过 numbers[\"one\"]=11 可以很容易的把 key 为 one 的字典值改为 11\n5. map 和其他基本型别不同，它不是 thread-safe，在多个 go-routine 存取时，必须使用 mutex lock 机制\n\n```\n  // 声明一个key是字符串，值为int的字典,这种方式的声明需要在使用之前使用make初始化\nvar numbers map[string]int\n// 另一种map的声明方式\nnumbers = make(map[string]int)\nnumbers[\"one\"] = 1  //赋值\nnumbers[\"ten\"] = 10 //赋值\nnumbers[\"three\"] = 3\n\nfmt.Println(\"第三个数字是: \", numbers[\"three\"]) // 读取数据\n// 打印出来如:第三个数字是: 3\n```\n\n#### make、new操作\n\n\n#### 小技巧\n1. 字符串大写\n```\nfunc main() {\n    x := \"hello!\"\n    for i := 0; i < len(x); i++ {\n        x := x[i]\n        if x != '!' {\n            x := x + 'A' - 'a'\n            fmt.Printf(\"%c\", x) // \"HELLO\"\n        }\n    }\n}\n```",htmlMode:"raw"})}}}]);