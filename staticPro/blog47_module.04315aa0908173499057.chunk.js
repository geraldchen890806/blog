(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{KtaY:function(n,o,e){"use strict";e.r(o);var r=e("q1tI"),a=e.n(r),f=e("IujW"),t=e.n(f),i=e("UZaz"),u=e.n(i);o.default=function(){return a.a.createElement(t.a,{source:u.a,htmlMode:"raw"})}},UZaz:function(n,o){n.exports="### CommonJS (nodejs)\n  同步加载，适合服务器端使用\n  模块输出的是一个值的拷贝\n```\n  // foo.js\n  // 定义我们希望暴露的更多行为\n  function foobar(){\n          this.foo = function(){\n                  console.log('Hello foo');\n          }\n  \n          this.bar = function(){\n                  console.log('Hello bar');\n          }\n  }\n  \n  // 把 foobar 暴露给其它模块\n  exports.foobar = foobar;\n  \n  // main.js\n  // 相对于使用文件与模块文件所在的同一目录路径获取模块  \n  var foobar = require('./foobar').foobar,\n      test   = new foobar();\n  \n  test.bar(); // 'Hello bar'\n```\n### AMD (require.js)\n异步加载，初始定义所以依赖模块\n```\n  // foo.js\n  define(function ( require ) {\n      var isReady = false, foobar;\n  \n      // 请注意在模块定义内部内联的 require 语句\n      require(['foo', 'bar'], function (foo, bar) {\n          isReady = true;\n          foobar = foo() + bar();\n      });\n  \n      // 我们仍可以返回一个模块\n      return {\n          isReady: isReady,\n          foobar: foobar\n      };\n  });\n  // main.js\n  require(['foo', 'bar'], function ( foo, bar ) {\n    // 这里写其余的代码\n    foo.doSomething();\n  });\n```\n### CMD (seajs)\n  CMD则是依赖就近，用的时候再require\n  AMD和CMD最大的区别是对依赖模块的执行时机处理不同，而不是加载的时机或者方式不同，二者皆为异步加载模块。\n\n```\n  define(function(require, exports, module) {\n    var clock = require('clock');\n    clock.start();\n  });\n```\n### ES6 import/export\n  模块输出的是值的引用, 编译时输出接口\n  CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成\n\n```\n  const foo = 10;\n  // foo更新会影响default值\n  export { foo as default }\n  // foo更新不会影响default值\n  export default foo;\n  foo = 11;\n```"}}]);