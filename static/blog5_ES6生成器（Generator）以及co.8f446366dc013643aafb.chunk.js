(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{464:function(n,e,t){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.default=function(){return o.default.createElement(r.default,{source:a.default,htmlMode:"raw"})};var o=s(t(2)),r=s(t(508)),a=s(t(787));function s(n){return n&&n.__esModule?n:{default:n}}},787:function(n,e){n.exports='我想关注生成器的应该都会知道tj大神的co模块，下面是我在学习co时的一点心得\n\n举个例子：\n\n    function * foo() {\n      yield 4;\n      var res = yield 2;\n      console.log("res:",res)\n      return 5;\n    }\n    \n    var g = foo();\n    g.next(1); // { value: 4, done: false }\n    g.next(2); // { value: 2, done: false }\n    g.next(3); // res:3 { value: 5, done: true }\n    \n这个例子反映了生成器的基本特性，有以下几点值得注意：\n\n  1.在调用foo()时，函数体中的逻辑并不会执行，直接调用g.next()时才会执行\n  \n  2.调用g.next()时，函数体中的逻辑才开始真正执行，返回结果{ value: \\\\*, done: \\\\* }\n  \n  3.当done属性为false时，表示该函数逻辑还未执行完，可以调用a.next()继续执行，否则不可继续调用\n  \n  4.最后一次返回的结果为return语句返回的结果，且done值为true。如果不写return，则值为undefined\n  \n  5.var res = yield 2这句是指，这一段逻辑返回2，在下一次调用g.next(3)时，res = 3。换句话说，这句只执行了后面半段就暂停了，等到再次调用g.next()时才会将参数赋给res并继续执行下面的逻辑\n    \ntj大神的co模块就是建立在这些特性上的\n\n    function * genFn(){\n      console.log(\'start\');\n      var s = yield function test(fn) {\n        $.get("http://www.baidu.com", fn)\n      }\n      console.log("s", s.statusCode)\n    }\n    \n    var gen = genFn();\n    var ret = gen.next();\n    ret.value(p);\n\n    function p(err, args) {\n      if (gen.next) {\n        var nextGen = gen.next(args)\n        if (nextGen.done) {\n          console.log(\'done\');\n        } else {\n          nextGen.value(p)\n        }\n      }\n    }\n输出：\n    \n    start\n    s 200\n    done\n    \n这里的ret.value(p) 就是运行test函数并且将p作为参数。那么test函数就会是这样的\n\n    function test(fn){\n        $.get("http://www.baidu.com", function(err, args) {\n          if (gen.next) {\n            var ret = gen.next(args);\n            //根据第5条特性，在这里会将args赋值给genFn里的s\n            if (ret.done) {\n              console.log(\'done\');\n            } else {\n              ret.value()\n            }\n          }\n        })\n    }\n    \n根据生成器的特性，第一次调用gen.next()时会返回test函数，这时ret.value == test，然后使用ret.value(p)调用test函数，在get的callback里运行gen.next，并将get返回值赋值给ret\n\n    \n\n参考 http://bg.biedalian.com/2013/12/21/harmony-generator.html\n        http://huangj.in/765\n'}}]);