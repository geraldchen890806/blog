(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{467:function(n,e,o){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.default=function(){return w.default.createElement(i.default,{source:d.default,htmlMode:"raw"})};var w=r(o(2)),i=r(o(508)),d=r(o(790));function r(n){return n&&n.__esModule?n:{default:n}}},790:function(n,e){n.exports="这段时间在做ie兼容chrome的工作 碰到一个问题 chrome不支持showModalDialog\n\n这还好 我们可以用window.open代替,兼容代码如下 (其实IE中也支持window.open 只是在跨域处理上window.open比较麻烦)\n\n```   \n//父页面\nif (window.chrome) {\n   window.open(...);\n} else if (window.showModalDialog) {\n   var str = window.showModalDialog(...)\n   //str为returnValue\n}\n\nfunction doReturnValue(str) {\n  ...\n}    \n```\n\n子页面已经returnValue兼容如下\n\n```\nif (window.chrome) { \n  window.opener.doReturnValue(str); \n} else {\n  window.returnValue = str;\n}\nwindow.close();\n```\n\n不过最近更奇葩的问题出现,打开的子页面涉及到跨域的问题。。。\n\n这时showModalDialog的returnValue===undifine并且window.opener.doReturnValue方法也不起作用\n\n还好我只要兼容chrome，html5的postMessage可以解决这个问题\n\n```\n//父页面\nif (window.chrome) {\n    window.addEventListener('message', function (e) {\n      if(e.data == 'closed') {\n       ...\n      }\n    })\n}\n\n//子页面\nif (window.chrome) {\n  window.opener.postMessage(\"closed\", \"*\");//* 不太安全 你懂的 应该写上父页面的域名\n}\n```\n\nFirefox,Safari,Opear,ie9+等支持html5的都可以用postMessage解决window.open跨域的问题\n\n至于ie9以下的 只能用window.showModalDialog了 \n\n其实我还是觉得随他去了 咱就用window.open吧。。。"}}]);