(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{469:function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=function(){return o.default.createElement(c.default,{source:l.default,htmlMode:"raw"})};var o=r(t(2)),c=r(t(508)),l=r(t(792));function r(e){return e&&e.__esModule?e:{default:e}}},792:function(e,n){e.exports='ie中使用ActiveXObject的loadXMl方法解析xml,其他浏览器可以使用DOMParser\n\n```\nfunction loadXml (text) {\n  var XMLDoc = null;\n  if (window.ActiveXObject) {\n    XMLDoc = new ActiveXObject("MSXML2.DOMDocument.6.0");//建议使用6.0版本\n    XMLDoc.async = false\n    XMLDoc.validateOnParse = true\n    XMLDoc.loadXML(text)  \n  } else {\n    var parseXml = new DOMParser();\n    XMLDoc = parseXml.parseFromString(text, "text/xml"); \n  }\n  return XMLDoc;\n}\n```\n\n然后我们就可以使用 loadXMl("...")来解析xml了\n\n但是还有个问题，就是取子节点以及节点值的问题\n\n```\n//ie\nXMLDoc_doc.selectSingleNode("CreditCardNumber").text\n//chrome,firefox...\nXMLDoc_doc.getElementsByTagName("CreditCardNumber")[0].innerHTML\n```\n为了不要每次取都要去判断浏览器 可以扩展下Node\n```\nfunction loadXml (text) {\n  var XMLDoc = null;\n  if (window.ActiveXObject) {\n    XMLDoc = new ActiveXObject("MSXML2.DOMDocument.6.0");\n    XMLDoc.async = false\n    XMLDoc.validateOnParse = true\n    XMLDoc.loadXML(text)  \n  } else {\n    var parseXml = new DOMParser();\n    XMLDoc = parseXml.parseFromString(text, "text/xml"); \n    Node.prototype.selectSingleNode = function(node) {\n      if (this.getElementsByTagName(node).length) {\n        var child = this.getElementsByTagName(node)[0];\n        child.text = child.innerHTML;\n        return child;\n      } else {\n        return null;\n      }\n    }\n  }\n  return XMLDoc;\n}\nvar XMLDoc = loadXml("<doc><test>ttt</test></doc>");\n                    \nvar text = XMLDoc.documentElement.selectSingleNode("test").text;//ttt\n\n实际上ie9+就已经支持DOMParser 但是为了兼容selectSingleNode方法 所以就在IE中都使用ActiveXObject\n\n```'}}]);